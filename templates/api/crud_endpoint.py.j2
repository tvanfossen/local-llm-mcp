{# 
Template: CRUD API Endpoint
Description: Complete CRUD operations for a resource with validation and error handling
Variables: resource_name, table_name, schema_class, primary_key
#}
{% extends "base/mcp_tool_base.py.j2" %}

{% set tool_name = resource_name|title + " CRUD API" %}
{% set tool_description = "Manage " + resource_name + " resources with full CRUD operations" %}

{% block imports %}
{{ super() }}
from datetime import datetime
from pathlib import Path
from typing import Optional

from src.core.config.manager.manager import ConfigManager
{% if database_type == "sqlite" %}
import sqlite3
{% elif database_type == "postgresql" %}
import psycopg2
from psycopg2.extras import RealDictCursor
{% endif %}
{% endblock %}

{% block additional_functions %}

async def create_{{ resource_name }}(args: dict[str, Any]) -> dict[str, Any]:
    """Create a new {{ resource_name }}"""
    try:
        {% for field in required_fields %}
        {{ field }} = args.get("{{ field }}")
        if not {{ field }}:
            return _create_error("Missing Parameter", "{{ field|title }} is required")
        {% endfor %}
        
        {% for field, default in optional_fields.items() %}
        {{ field }} = args.get("{{ field }}", {{ default|tojson }})
        {% endfor %}
        
        # Connect to database
        db_connection = _get_database_connection()
        cursor = db_connection.cursor()
        
        # Insert new record
        insert_query = """
            INSERT INTO {{ table_name }} ({{ all_fields|join(', ') }}, created_at)
            VALUES ({{ '%s, ' * (all_fields|length) }}%s)
            RETURNING {{ primary_key }}
        """
        
        values = [{{ all_fields|map('string')|map('add', ' = ')|map('add', all_fields)|join(', ') }}, datetime.now()]
        cursor.execute(insert_query, values)
        
        new_id = cursor.fetchone()[0]
        db_connection.commit()
        
        success_msg = (
            f"✅ **{{ resource_name|title }} Created**\n\n"
            f"🆔 **ID:** {new_id}\n"
            {% for field in display_fields %}
            f"📝 **{{ field|title }}:** {{{ field }}}\n"
            {% endfor %}
        )
        
        return _create_success(success_msg)
        
    except Exception as e:
        logger.error(f"Failed to create {{ resource_name }}: {e}")
        return _handle_exception(e, "Create {{ resource_name|title }}")
    finally:
        if 'db_connection' in locals():
            db_connection.close()


async def get_{{ resource_name }}(args: dict[str, Any]) -> dict[str, Any]:
    """Get {{ resource_name }} by ID"""
    try:
        {{ primary_key }} = args.get("{{ primary_key }}")
        if not {{ primary_key }}:
            return _create_error("Missing Parameter", "{{ primary_key|title }} is required")
        
        # Connect to database
        db_connection = _get_database_connection()
        cursor = db_connection.cursor()
        
        # Query record
        select_query = f"SELECT * FROM {{ table_name }} WHERE {{ primary_key }} = %s"
        cursor.execute(select_query, ({{ primary_key }},))
        
        record = cursor.fetchone()
        if not record:
            return _create_error("Not Found", f"{{ resource_name|title }} not found: {{{ primary_key }}}")
        
        # Format response
        record_dict = dict(zip([desc[0] for desc in cursor.description], record))
        
        info_msg = _format_{{ resource_name }}_info(record_dict)
        return _create_success(info_msg)
        
    except Exception as e:
        logger.error(f"Failed to get {{ resource_name }}: {e}")
        return _handle_exception(e, "Get {{ resource_name|title }}")
    finally:
        if 'db_connection' in locals():
            db_connection.close()


async def update_{{ resource_name }}(args: dict[str, Any]) -> dict[str, Any]:
    """Update {{ resource_name }} by ID"""
    try:
        {{ primary_key }} = args.get("{{ primary_key }}")
        if not {{ primary_key }}:
            return _create_error("Missing Parameter", "{{ primary_key|title }} is required")
        
        # Build update fields
        update_fields = []
        update_values = []
        
        {% for field in updatable_fields %}
        if "{{ field }}" in args:
            update_fields.append("{{ field }} = %s")
            update_values.append(args["{{ field }}"])
        {% endfor %}
        
        if not update_fields:
            return _create_error("No Updates", "No valid update fields provided")
        
        # Add updated_at timestamp
        update_fields.append("updated_at = %s")
        update_values.append(datetime.now())
        update_values.append({{ primary_key }})
        
        # Connect to database
        db_connection = _get_database_connection()
        cursor = db_connection.cursor()
        
        # Update record
        update_query = f"""
            UPDATE {{ table_name }} 
            SET {', '.join(update_fields)}
            WHERE {{ primary_key }} = %s
            RETURNING *
        """
        
        cursor.execute(update_query, update_values)
        updated_record = cursor.fetchone()
        
        if not updated_record:
            return _create_error("Not Found", f"{{ resource_name|title }} not found: {{{ primary_key }}}")
        
        db_connection.commit()
        
        # Format response
        record_dict = dict(zip([desc[0] for desc in cursor.description], updated_record))
        
        success_msg = (
            f"✅ **{{ resource_name|title }} Updated**\n\n"
            f"🆔 **ID:** {{{ primary_key }}}\n"
            f"📝 **Updated Fields:** {len(update_fields) - 1}\n\n"
        )
        success_msg += _format_{{ resource_name }}_info(record_dict)
        
        return _create_success(success_msg)
        
    except Exception as e:
        logger.error(f"Failed to update {{ resource_name }}: {e}")
        return _handle_exception(e, "Update {{ resource_name|title }}")
    finally:
        if 'db_connection' in locals():
            db_connection.close()


async def delete_{{ resource_name }}(args: dict[str, Any]) -> dict[str, Any]:
    """Delete {{ resource_name }} by ID"""
    try:
        {{ primary_key }} = args.get("{{ primary_key }}")
        if not {{ primary_key }}:
            return _create_error("Missing Parameter", "{{ primary_key|title }} is required")
        
        force = args.get("force", False)
        
        # Connect to database
        db_connection = _get_database_connection()
        cursor = db_connection.cursor()
        
        # Get record info before deletion
        cursor.execute(f"SELECT * FROM {{ table_name }} WHERE {{ primary_key }} = %s", ({{ primary_key }},))
        record = cursor.fetchone()
        
        if not record:
            return _create_error("Not Found", f"{{ resource_name|title }} not found: {{{ primary_key }}}")
        
        {% if soft_delete %}
        # Soft delete
        cursor.execute(
            f"UPDATE {{ table_name }} SET deleted_at = %s WHERE {{ primary_key }} = %s",
            (datetime.now(), {{ primary_key }})
        )
        action = "soft deleted"
        {% else %}
        # Hard delete
        if not force:
            return _create_error(
                "Confirmation Required", 
                f"Use 'force: true' to confirm deletion of {{ resource_name }} {{{ primary_key }}}"
            )
        
        cursor.execute(f"DELETE FROM {{ table_name }} WHERE {{ primary_key }} = %s", ({{ primary_key }},))
        action = "deleted"
        {% endif %}
        
        db_connection.commit()
        
        success_msg = (
            f"🗑️ **{{ resource_name|title }} {action.title()}**\n\n"
            f"🆔 **ID:** {{{ primary_key }}}\n"
            f"📝 **Action:** {action}"
        )
        
        return _create_success(success_msg)
        
    except Exception as e:
        logger.error(f"Failed to delete {{ resource_name }}: {e}")
        return _handle_exception(e, "Delete {{ resource_name|title }}")
    finally:
        if 'db_connection' in locals():
            db_connection.close()


async def list_{{ resource_name }}s(args: dict[str, Any] = None) -> dict[str, Any]:
    """List {{ resource_name }}s with optional filtering and pagination"""
    try:
        if args is None:
            args = {}
            
        limit = args.get("limit", 50)
        offset = args.get("offset", 0)
        sort_by = args.get("sort_by", "{{ primary_key }}")
        sort_order = args.get("sort_order", "DESC")
        
        # Build WHERE clause for filters
        where_conditions = []
        where_values = []
        
        {% for field in filterable_fields %}
        if "{{ field }}" in args:
            where_conditions.append("{{ field }} = %s")
            where_values.append(args["{{ field }}"])
        {% endfor %}
        
        {% if soft_delete %}
        # Exclude soft deleted records
        where_conditions.append("deleted_at IS NULL")
        {% endif %}
        
        where_clause = "WHERE " + " AND ".join(where_conditions) if where_conditions else ""
        
        # Connect to database
        db_connection = _get_database_connection()
        cursor = db_connection.cursor()
        
        # Count total records
        count_query = f"SELECT COUNT(*) FROM {{ table_name }} {where_clause}"
        cursor.execute(count_query, where_values)
        total_count = cursor.fetchone()[0]
        
        # Query records with pagination
        list_query = f"""
            SELECT * FROM {{ table_name }} 
            {where_clause}
            ORDER BY {sort_by} {sort_order}
            LIMIT %s OFFSET %s
        """
        
        cursor.execute(list_query, where_values + [limit, offset])
        records = cursor.fetchall()
        
        # Format response
        if not records:
            return _create_success(f"📋 **{{ resource_name|title }}s**\n\nNo {{ resource_name }}s found.")
        
        records_list = []
        for record in records:
            record_dict = dict(zip([desc[0] for desc in cursor.description], record))
            records_list.append(record_dict)
        
        list_msg = (
            f"📋 **{{ resource_name|title }}s** ({len(records)} of {total_count})\n\n"
            f"📊 **Page:** {offset // limit + 1} | **Per Page:** {limit}\n\n"
        )
        
        for record in records_list:
            list_msg += _format_{{ resource_name }}_summary(record) + "\n"
        
        return _create_success(list_msg)
        
    except Exception as e:
        logger.error(f"Failed to list {{ resource_name }}s: {e}")
        return _handle_exception(e, "List {{ resource_name|title }}s")
    finally:
        if 'db_connection' in locals():
            db_connection.close()


def _get_database_connection():
    """Get database connection"""
    config_manager = ConfigManager()
    
    {% if database_type == "sqlite" %}
    db_path = config_manager.system.workspace_root / "data" / "{{ database_name }}.db"
    db_path.parent.mkdir(exist_ok=True)
    return sqlite3.connect(str(db_path))
    {% elif database_type == "postgresql" %}
    return psycopg2.connect(
        host=config_manager.database.host,
        port=config_manager.database.port,
        database=config_manager.database.name,
        user=config_manager.database.user,
        password=config_manager.database.password,
        cursor_factory=RealDictCursor
    )
    {% endif %}


def _format_{{ resource_name }}_info(record: dict) -> str:
    """Format {{ resource_name }} information for display"""
    info = f"📄 **{{ resource_name|title }} Details**\n\n"
    
    {% for field in display_fields %}
    info += f"{% if field == primary_key %}🆔{% elif field in ['name', 'title'] %}📝{% elif field in ['email'] %}📧{% elif field in ['created_at', 'updated_at'] %}📅{% else %}📋{% endif %} **{{ field|title|replace('_', ' ') }}:** {record.get('{{ field }}', 'N/A')}\n"
    {% endfor %}
    
    return info


def _format_{{ resource_name }}_summary(record: dict) -> str:
    """Format {{ resource_name }} summary for listing"""
    {% if summary_fields %}
    return (
        f"🔸 **{record.get('{{ summary_fields[0] }}', 'N/A')}** (`{record.get('{{ primary_key }}')}`) - "
        f"{record.get('{{ summary_fields[1] }}', 'N/A')}"
    )
    {% else %}
    return f"🔸 **{{ resource_name|title }}** (`{record.get('{{ primary_key }}')}`) - {record.get('created_at', 'N/A')}"
    {% endif %}

{% endblock %}